# Add build rules for Rust bindings.
--- /dev/null
+++ rust/bssl-crypto/BUILD
@@ -0,0 +1,14 @@
+load("@rules_rust//rust:defs.bzl", "rust_library", "rust_test")
+
+rust_library(
+    name = "bssl-crypto",
+    srcs = glob(["src/**/*.rs"]),
+    crate_features = ["std"],
+    visibility = ["//visibility:public"],
+    deps = ["//rust/bssl-sys"],
+)
+
+rust_test(
+    name = "bssl-crypto_test",
+    crate = ":bssl-crypto",
+)

--- /dev/null
+++ rust/bssl-sys/BUILD
@@ -0,0 +1,52 @@
+load("@rules_cc//cc:defs.bzl", "cc_library")
+load("@rules_rust//rust:defs.bzl", "rust_library")
+load("@rules_rust_bindgen//:defs.bzl", "rust_bindgen")
+
+rust_library(
+    name = "bssl-sys",
+    srcs = glob(["src/**/*.rs"]),
+    compile_data = [":bindgen"],
+    rustc_env = {"BINDGEN_RS_FILE": "$(execpath :bindgen)"},
+    rustc_flags = ["--cfg=bindgen_rs_file"],
+    visibility = ["//rust/bssl-crypto:__pkg__"],
+    deps = [":bindgen_c_thunks_library"],
+)
+
+# Flags derived from CMakeLists.txt.
+rust_bindgen(
+    name = "bindgen",
+    bindgen_flags = [
+        "--allowlist-file=.*[[:punct:]]include[[:punct:]]openssl[[:punct:]].*\\.h",
+        "--no-derive-default",
+        "--enable-function-attribute-detection",
+        "--use-core",
+        "--default-macro-constant-type=signed",
+        "--rustified-enum=point_conversion_form_t",
+    ],
+    cc_lib = ":wrapper",
+    header = "wrapper.h",
+    wrap_static_fns = True,
+)
+
+filegroup(
+    name = "bindgen_c_thunks",
+    srcs = [":bindgen"],
+    output_group = "bindgen_c_thunks",
+)
+
+cc_library(
+    name = "bindgen_c_thunks_library",
+    srcs = [":bindgen_c_thunks"],
+    copts = ["-I."],
+    deps = [":wrapper"],
+)
+
+cc_library(
+    name = "wrapper",
+    srcs = ["rust_wrapper.h"],
+    hdrs = ["wrapper.h"],
+    deps = [
+        "//:crypto",
+        "//:ssl",
+    ],
+)

# Add `Kem::get_public_key` to get the public key from a private key.
--- rust/bssl-crypto/src/hpke.rs
+++ rust/bssl-crypto/src/hpke.rs
@@ -153,3 +153,36 @@ impl Kem {
         (pub_key, priv_key)
     }
+
+    /// Get a private key's corresponding public key.
+    pub fn get_public_key(&self, priv_key: &[u8]) -> Option<Vec<u8>> {
+        let mut key = scoped::EvpHpkeKey::new();
+        // Safety: `key` and `self` must be valid and this function doesn't
+        // take ownership of either.
+        let ret = unsafe {
+            bssl_sys::EVP_HPKE_KEY_init(
+                key.as_mut_ffi_ptr(),
+                self.as_ffi_ptr(),
+                priv_key.as_ptr(),
+                priv_key.len(),
+            )
+        };
+        if ret != 1 {
+            return None;
+        }
+
+        let max_len = bssl_sys::EVP_HPKE_MAX_PUBLIC_KEY_LENGTH as usize;
+        let pub_key = unsafe {
+            with_output_vec(max_len, |out| {
+                let mut out_len = 0usize;
+                let ret =
+                    bssl_sys::EVP_HPKE_KEY_public_key(key.as_ffi_ptr(), out, &mut out_len, max_len);
+                // If `max_len` is correct then this function never fails.
+                assert_eq!(ret, 1);
+                assert!(out_len <= max_len);
+                // Safety: `out_len` bytes have been written, as required.
+                out_len
+            })
+        };
+        Some(pub_key)
+    }
 }
