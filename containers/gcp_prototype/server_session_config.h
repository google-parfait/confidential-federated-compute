// Copyright 2025 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// C FFI header defining the interface between C++ server code and the Rust
// library (`server_session_config.rs`) responsible for key generation and
// creating the Oak ServerSession configuration.

#ifndef SERVER_SESSION_CONFIG_H
#define SERVER_SESSION_CONFIG_H

#include <cstddef>  // For size_t

// Forward declare opaque types used by the FFI, matching Oak's structure.
namespace oak {
namespace session {
namespace bindings {
// Opaque struct representing the Rust SessionConfig.
class SessionConfig;
// Opaque struct representing the handle to the Rust SigningKey.
// The actual definition is in Rust; C++ only deals with pointers to it.
struct SigningKeyHandle;
}  // namespace bindings
using SessionConfig = bindings::SessionConfig;
using SigningKeyHandle = bindings::SigningKeyHandle;
}  // namespace session
}  // namespace oak

// Extern "C" block ensures C-style linking for FFI compatibility.
#ifdef __cplusplus
extern "C" {
#endif

// --- Key Management Functions (Implemented in Rust) ---

/**
 * @brief Generates a P-256 key pair (ECDSA).
 *
 * Implemented in Rust (`server_session_config.rs`). Creates a signing key and
 * its corresponding verification key.
 *
 * @param out_public_key_bytes Buffer provided by C++ to write the raw public
 * key bytes (SEC1 encoded, uncompressed format, 65 bytes for P-256).
 * @param public_key_capacity The size (capacity) of the `out_public_key_bytes`
 * buffer. Must be at least 65.
 * @param out_private_key_handle Output parameter; Rust writes a pointer
 * (handle) to the generated private key object here. Ownership of the
 * pointed-to object is transferred to the C++ caller, who must later pass it to
 * `create_server_session_config`.
 * @return The number of bytes written to `out_public_key_bytes` (typically 65)
 * on success, or -1 on error (e.g., buffer too small).
 */
int generate_key_pair(unsigned char* out_public_key_bytes,
                      size_t public_key_capacity,
                      oak::session::SigningKeyHandle** out_private_key_handle);

// --- Config Creation Function (Implemented in Rust) ---

/**
 * @brief Creates an Oak ServerSession configuration object.
 *
 * Implemented in Rust (`server_session_config.rs`). Takes the attestation
 * token and the private key handle (previously generated by
 * `generate_key_pair`) to construct the Oak SessionConfig needed for the
 * server. This includes setting up the custom assertion generator which
 * provides the JWT and handles session binding using the private key.
 *
 * @param attestation_token Pointer to the raw bytes of the JWT attestation
 * token.
 * @param attestation_token_len Length of the JWT token data.
 * @param private_key_handle Pointer (handle) to the private key object
 * generated by `generate_key_pair`. Ownership of the underlying Rust object is
 * transferred *from* C++ *to* this Rust function.
 * @return A raw pointer to the created SessionConfig object. Ownership is
 * transferred to the C++ caller (typically
 * `oak::session::ServerSession::Create`).
 */
oak::session::SessionConfig* create_server_session_config(
    const char* attestation_token, size_t attestation_token_len,
    oak::session::SigningKeyHandle* private_key_handle);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // SERVER_SESSION_CONFIG_H
